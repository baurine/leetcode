# Euler Note

对 euler 解题的一些总结。加 v 的表示有点意思，可用于面试。

递归被重度使用。

## 第 1 ~ 12 题

略。基本都是暴力枚举。

## 第 13 题 (v)

问题：

100 个 50 位数的和的最高 10 位数。

解题思路：

将每个 50 位拆成 5 个 10 位数，先将 100 个最后 10 位数相加，得到进位数，然后将次后 10 位数相加，加上前面得到的进位数，
依次这样操作。

## 第 14 题

问题：

随便取一个数，如果这个数是奇数，那么它的下一个数是 3n+1，如果是偶数，而下一个数是 n/2，依此类推，直到这个数变成 1

示例：13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1

则 13 到 1 的序列长度为 10

求 1000000 以下的数里面，哪个数变成 1 的序列最长

解题思路：暴力枚举 (试了缓存中间结果，但缓存命中率太低，效率反而低)

## 第 15 题 (v)

问题：一个 2x2 的网格，总共有 6 种路径可以从左上角到右下角，求 20x20 的网格有多少种路径。

解题思路：递归 + 缓存中间结果 (不缓存中间结果的话需要很长时间才能得到结果)

## 第 16 题 (v)

问题：求 2^1000 的十进制的值的每位数加起来总和。

解题思路：用 `Vec<u32>` 存储

```
n  -- vec
1  -- 2
2  -- 4
3  -- 8
4  -- 6 1
5  -- 2 3
6  -- 4 6
7  -- 8 2 1
8  -- 6 5 2
9  -- 2 1 5
10 -- 4 2 0 1
```

收获：

go 里面使用 append 往切片里添加元素：`slice = append(slice, new_item)`

## 第 17 题

问题：求 1 到 1000 这 1000 个数转换成英语单词后的长度总和。

解题思路：分解，递归。

收获：

rust 解法中学习到了 match 和 match guard, format!() 的用法。

go 中用 fmt.Sprintf() 进行字符串格式化，用 `strings.split(str, spliter)` 进行 split。

## 第 18 题 (v)

问题：求一个大三角 (15 行) 从顶端到底部的一条路径，使路径上的值的和为最大值，求这个最大值。

```
   3
  7 4
 2 4 6
8 5 9 3
```

比如上例中，和最大值路径为 2 -> 7 -> 4 -> 9，和为 23。

解题思路：可以转换成求二叉树的和最大值路径，依旧使用递归法。

收获：Go 里面没有三目表达式。
